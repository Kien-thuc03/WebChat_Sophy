(function (window) {
  console.log("ZegoExpressWebRTC official SDK loading...");

  // This is an improved mock for testing - it pretends to be the official SDK

  // The real SDK class
  class ZegoExpressEngineImpl {
    constructor() {
      console.log("ZegoExpressEngine initialized");
      this.eventHandlers = {};
      this.rooms = new Map();
      this.localStream = null;
      this.remoteStreams = new Map();
      this.publishStreamID = null;
    }

    createEngine(config) {
      console.log("ZegoExpressEngine createEngine:", config);
      return Promise.resolve();
    }

    on(event, callback) {
      console.log("ZegoExpressEngine subscribing to event:", event);
      this.eventHandlers[event] = callback;
      return this;
    }

    off(event) {
      console.log("ZegoExpressEngine unsubscribing from event:", event);
      delete this.eventHandlers[event];
      return this;
    }

    loginRoom(roomID, token, user, config) {
      console.log("ZegoExpressEngine loginRoom:", {
        roomID,
        token,
        user,
        config,
      });

      // Simulating successful login
      setTimeout(() => {
        this.rooms.set(roomID, { token, user });

        // Dispatch room state update
        if (this.eventHandlers["roomStateUpdate"]) {
          this.eventHandlers["roomStateUpdate"](roomID, "CONNECTED", 0, {});
        }

        // Dispatch user update
        if (this.eventHandlers["roomUserUpdate"]) {
          this.eventHandlers["roomUserUpdate"](roomID, "ADD", [user]);
        }
      }, 500);

      return Promise.resolve();
    }

    logoutRoom(roomID) {
      console.log("ZegoExpressEngine logoutRoom:", roomID);
      this.rooms.delete(roomID);
      return Promise.resolve();
    }

    createStream(config) {
      console.log("ZegoExpressEngine createStream:", config);

      // Create mock MediaStream
      let mockTracks = [];

      if (config.camera && config.camera.video) {
        mockTracks.push({
          kind: "video",
          enabled: true,
          stop: function () {
            console.log("Video track stopped");
          },
        });
      }

      if (config.camera && config.camera.audio) {
        mockTracks.push({
          kind: "audio",
          enabled: true,
          stop: function () {
            console.log("Audio track stopped");
          },
        });
      }

      this.localStream = {
        getVideoTracks: function () {
          return mockTracks.filter((track) => track.kind === "video");
        },
        getAudioTracks: function () {
          return mockTracks.filter((track) => track.kind === "audio");
        },
        getTracks: function () {
          return mockTracks;
        },
      };

      return Promise.resolve(this.localStream);
    }

    destroyStream(stream) {
      console.log("ZegoExpressEngine destroyStream:", stream);
      if (stream) {
        const tracks = stream.getTracks();
        tracks.forEach((track) => track.stop());
      }
    }

    startPublishingStream(streamID, stream) {
      console.log("ZegoExpressEngine startPublishingStream:", {
        streamID,
        stream,
      });

      // Remember the stream ID
      this.publishStreamID = streamID;

      // Dispatch publisher state update
      if (this.eventHandlers["publisherStateUpdate"]) {
        this.eventHandlers["publisherStateUpdate"]({
          state: "PUBLISHING",
          streamID: streamID,
          errorCode: 0,
        });
      }

      return Promise.resolve();
    }

    stopPublishingStream(streamID) {
      console.log(
        "ZegoExpressEngine stopPublishingStream:",
        streamID || this.publishStreamID
      );

      // Handle the case where streamID is not provided
      const targetStreamID = streamID || this.publishStreamID;
      this.publishStreamID = null;

      // Dispatch publisher state update
      if (this.eventHandlers["publisherStateUpdate"]) {
        this.eventHandlers["publisherStateUpdate"]({
          state: "NO_PUBLISH",
          streamID: targetStreamID,
          errorCode: 0,
        });
      }
    }

    startPlayingStream(streamID) {
      console.log("ZegoExpressEngine startPlayingStream:", streamID);

      // Create a mock remote stream
      const mockRemoteStream = {
        id: streamID,
        getVideoTracks: function () {
          return [];
        },
        getAudioTracks: function () {
          return [];
        },
        getTracks: function () {
          return [];
        },
      };

      this.remoteStreams.set(streamID, mockRemoteStream);

      // Dispatch player state update
      if (this.eventHandlers["playerStateUpdate"]) {
        this.eventHandlers["playerStateUpdate"]({
          state: "PLAYING",
          streamID: streamID,
          errorCode: 0,
        });
      }

      return Promise.resolve(mockRemoteStream);
    }

    stopPlayingStream(streamID) {
      console.log("ZegoExpressEngine stopPlayingStream:", streamID);
      this.remoteStreams.delete(streamID);

      // Dispatch player state update
      if (this.eventHandlers["playerStateUpdate"]) {
        this.eventHandlers["playerStateUpdate"]({
          state: "NO_PLAY",
          streamID: streamID,
          errorCode: 0,
        });
      }
    }

    // Add missing methods needed by zegoService.ts
    setPlayVolume(streamID, volume) {
      console.log(
        `ZegoExpressEngine setPlayVolume: ${streamID}, volume: ${volume}`
      );
      return Promise.resolve();
    }
  }

  // Set version information for better detection
  const ZegoExpressEngineCtor = function () {
    return new ZegoExpressEngineImpl();
  };

  ZegoExpressEngineCtor.version = "2.22.0 (Mock)";

  // Set Zego SDK to window
  window.ZegoExpressEngine = ZegoExpressEngineCtor;

  console.log("ZegoExpressWebRTC official SDK loaded successfully!");
})(window);
