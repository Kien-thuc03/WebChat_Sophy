(function(window) {
    console.log("ZegoExpressWebRTC mock loading...");

    // Global room state to simulate real server communication
    const globalRooms = {}; // roomID -> {users: [{userID, userName}], streams: [{streamID, userID}]}

    // The real SDK class
    class ZegoExpressEngineImpl {
        constructor(appID, server) {
            console.log(
                `ZegoExpressEngine mock initialized with appID: ${appID}, server: ${server || "default"}`
            );
            this.eventHandlers = {};
            this.rooms = new Map();
            this.localStream = null;
            this.remoteStreams = new Map();
            this.publishStreamID = null;
            this.currentRoomID = null;
            this.currentUserID = null;
        }

        createEngine(config) {
            console.log("ZegoExpressEngine mock createEngine:", config);
            return Promise.resolve();
        }

        on(event, callback) {
            console.log("ZegoExpressEngine mock subscribing to event:", event);
            this.eventHandlers[event] = callback;
            return this;
        }

        off(event) {
            console.log("ZegoExpressEngine mock unsubscribing from event:", event);
            delete this.eventHandlers[event];
            return this;
        }

        loginRoom(roomID, token, user, config) {
            console.log("ZegoExpressEngine mock loginRoom:", {
                roomID,
                tokenPrefix: token ? token.substring(0, 10) + "..." : "no-token",
                user,
                config,
            });

            // Store current room and user information
            this.currentRoomID = roomID;
            this.currentUserID = user.userID;

            // Initialize global room if not exists
            if (!globalRooms[roomID]) {
                globalRooms[roomID] = {
                    users: [],
                    streams: [],
                };
            }

            // Register this user in the global room
            const existingUserIndex = globalRooms[roomID].users.findIndex(
                (u) => u.userID === user.userID
            );
            if (existingUserIndex >= 0) {
                // Update existing user
                globalRooms[roomID].users[existingUserIndex] = user;
            } else {
                // Add new user
                globalRooms[roomID].users.push(user);
            }

            // Track this room for the current instance
            this.rooms.set(roomID, { token, user });

            // Dispatch room state update (simulating successful connection)
            setTimeout(() => {
                if (this.eventHandlers["roomStateUpdate"]) {
                    this.eventHandlers["roomStateUpdate"](roomID, "CONNECTED", 0, {});
                }

                // Notify about existing users (excluding self)
                const otherUsers = globalRooms[roomID].users.filter(
                    (u) => u.userID !== user.userID
                );
                if (otherUsers.length > 0 && this.eventHandlers["roomUserUpdate"]) {
                    this.eventHandlers["roomUserUpdate"](roomID, "ADD", otherUsers);
                }

                // Notify about existing streams in the room (excluding own streams)
                const otherStreams = globalRooms[roomID].streams.filter(
                    (s) => s.user.userID !== user.userID
                );
                if (otherStreams.length > 0 && this.eventHandlers["roomStreamUpdate"]) {
                    this.eventHandlers["roomStreamUpdate"](roomID, "ADD", otherStreams);
                }
            }, 500);

            return Promise.resolve();
        }

        logoutRoom(roomID) {
            console.log("ZegoExpressEngine mock logoutRoom:", roomID);

            // Remove user from global room
            if (globalRooms[roomID] && this.currentUserID) {
                // Remove user's streams from the room
                globalRooms[roomID].streams = globalRooms[roomID].streams.filter(
                    (stream) => stream.user.userID !== this.currentUserID
                );

                // Remove user from the room
                globalRooms[roomID].users = globalRooms[roomID].users.filter(
                    (user) => user.userID !== this.currentUserID
                );

                // Notify other users in the room about this user leaving
                for (const engine of window._zegoEngineInstances || []) {
                    if (
                        engine !== this &&
                        engine.currentRoomID === roomID &&
                        engine.eventHandlers["roomUserUpdate"]
                    ) {
                        const leavingUser = [{ userID: this.currentUserID }];
                        engine.eventHandlers["roomUserUpdate"](
                            roomID,
                            "DELETE",
                            leavingUser
                        );

                        // Notify about stream removal
                        const removedStreams = globalRooms[roomID].streams.filter(
                            (stream) => stream.user.userID === this.currentUserID
                        );
                        if (
                            removedStreams.length > 0 &&
                            engine.eventHandlers["roomStreamUpdate"]
                        ) {
                            engine.eventHandlers["roomStreamUpdate"](
                                roomID,
                                "DELETE",
                                removedStreams
                            );
                        }
                    }
                }
            }

            this.rooms.delete(roomID);
            this.currentRoomID = null;
            return Promise.resolve();
        }

        createStream(config) {
            console.log("ZegoExpressEngine mock createStream:", config);

            // Create mock MediaStream
            let mockTracks = [];

            if (config.camera && config.camera.video) {
                mockTracks.push({
                    kind: "video",
                    enabled: true,
                    stop: function() {
                        console.log("Video track stopped");
                    },
                });
            }

            if (config.camera && config.camera.audio) {
                mockTracks.push({
                    kind: "audio",
                    enabled: true,
                    stop: function() {
                        console.log("Audio track stopped");
                    },
                });
            }

            this.localStream = {
                getVideoTracks: function() {
                    return mockTracks.filter((track) => track.kind === "video");
                },
                getAudioTracks: function() {
                    return mockTracks.filter((track) => track.kind === "audio");
                },
                getTracks: function() {
                    return mockTracks;
                },
            };

            return Promise.resolve(this.localStream);
        }

        destroyStream(stream) {
            console.log("ZegoExpressEngine mock destroyStream:", stream);
            if (stream) {
                const tracks = stream.getTracks();
                tracks.forEach((track) => track.stop());
            }
        }

        startPublishingStream(streamID, stream) {
            console.log("ZegoExpressEngine mock startPublishingStream:", {
                streamID,
                stream: stream ? "MediaStream object" : "null",
            });

            // Save the stream ID
            this.publishStreamID = streamID;

            // Register this stream in the global room
            if (this.currentRoomID && this.currentUserID) {
                const room = globalRooms[this.currentRoomID];
                if (room) {
                    // Find the current user
                    const currentUser = room.users.find(
                        (user) => user.userID === this.currentUserID
                    );
                    if (currentUser) {
                        // Add this stream to the room
                        const streamInfo = {
                            streamID,
                            user: currentUser,
                        };

                        const existingStreamIndex = room.streams.findIndex(
                            (s) => s.streamID === streamID
                        );
                        if (existingStreamIndex >= 0) {
                            // Update existing stream
                            room.streams[existingStreamIndex] = streamInfo;
                        } else {
                            // Add new stream
                            room.streams.push(streamInfo);
                        }

                        // Notify other users in the room about this new stream
                        for (const engine of window._zegoEngineInstances || []) {
                            if (
                                engine !== this &&
                                engine.currentRoomID === this.currentRoomID &&
                                engine.eventHandlers["roomStreamUpdate"]
                            ) {
                                engine.eventHandlers["roomStreamUpdate"](
                                    this.currentRoomID,
                                    "ADD", [streamInfo]
                                );
                            }
                        }
                    }
                }
            }

            // Dispatch publisher state update
            if (this.eventHandlers["publisherStateUpdate"]) {
                this.eventHandlers["publisherStateUpdate"]({
                    state: "PUBLISHING",
                    streamID: streamID,
                    errorCode: 0,
                });
            }

            return Promise.resolve();
        }

        stopPublishingStream(streamID) {
            console.log("ZegoExpressEngine mock stopPublishingStream:", streamID);

            // Remove this stream from the global room
            if (this.currentRoomID && streamID) {
                const room = globalRooms[this.currentRoomID];
                if (room) {
                    // Remove the stream
                    const removedStream = room.streams.find(
                        (s) => s.streamID === streamID
                    );
                    room.streams = room.streams.filter((s) => s.streamID !== streamID);

                    // Notify other users in the room about this stream removal
                    if (removedStream) {
                        for (const engine of window._zegoEngineInstances || []) {
                            if (
                                engine !== this &&
                                engine.currentRoomID === this.currentRoomID &&
                                engine.eventHandlers["roomStreamUpdate"]
                            ) {
                                engine.eventHandlers["roomStreamUpdate"](
                                    this.currentRoomID,
                                    "DELETE", [removedStream]
                                );
                            }
                        }
                    }
                }
            }

            // Dispatch publisher state update
            if (this.eventHandlers["publisherStateUpdate"]) {
                this.eventHandlers["publisherStateUpdate"]({
                    state: "NO_PUBLISH",
                    streamID: streamID || this.publishStreamID,
                    errorCode: 0,
                });
            }

            this.publishStreamID = null;
        }

        startPlayingStream(streamID) {
            console.log("ZegoExpressEngine mock startPlayingStream:", streamID);

            // Create a mock remote video element
            const mockVideoElement = document.createElement("video");
            mockVideoElement.autoplay = true;
            mockVideoElement.muted = false;
            mockVideoElement.playsInline = true;
            mockVideoElement.style.width = "100%";
            mockVideoElement.style.height = "100%";
            mockVideoElement.style.backgroundColor = "#333";
            mockVideoElement.setAttribute("id", `remote-stream-${streamID}`);

            // Create a mock remote stream
            const mockRemoteStream = {
                id: streamID,
                getVideoTracks: function() {
                    return [{ kind: "video", enabled: true }];
                },
                getAudioTracks: function() {
                    return [{ kind: "audio", enabled: true }];
                },
                getTracks: function() {
                    return [
                        { kind: "video", enabled: true },
                        { kind: "audio", enabled: true },
                    ];
                },
                // Add this to make it compatible with standard MediaStream
                streamID: streamID,
            };

            this.remoteStreams.set(streamID, mockRemoteStream);

            // Dispatch player state update
            if (this.eventHandlers["playerStateUpdate"]) {
                this.eventHandlers["playerStateUpdate"]({
                    state: "PLAYING",
                    streamID: streamID,
                    errorCode: 0,
                });
            }

            return Promise.resolve(mockRemoteStream);
        }

        stopPlayingStream(streamID) {
            console.log("ZegoExpressEngine mock stopPlayingStream:", streamID);
            this.remoteStreams.delete(streamID);

            // Dispatch player state update
            if (this.eventHandlers["playerStateUpdate"]) {
                this.eventHandlers["playerStateUpdate"]({
                    state: "NO_PLAY",
                    streamID: streamID,
                    errorCode: 0,
                });
            }
        }

        // Add compatibility for setPlayVolume
        setPlayVolume(streamID, volume) {
            console.log(
                `ZegoExpressEngine mock setPlayVolume: streamID=${streamID}, volume=${volume}`
            );
            return Promise.resolve();
        }
    }

    // Keep track of all engine instances to simulate cross-instance communication
    if (!window._zegoEngineInstances) {
        window._zegoEngineInstances = [];
    }

    // Factory function to create SDK instances
    window.ZegoExpressEngine = function(appID, server) {
        const engine = new ZegoExpressEngineImpl(appID, server);
        window._zegoEngineInstances.push(engine);
        return engine;
    };

    console.log("ZegoExpressWebRTC mock loaded successfully!");
})(window);